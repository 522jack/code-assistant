package com.codeassistant.review

import com.codeassistant.github.PullRequestInfo

/**
 * Formatter for code review results into markdown
 */
class ReviewFormatter {
    /**
     * Format code review result as markdown comment for PR
     */
    fun formatReview(
        result: CodeReviewResult,
        prInfo: PullRequestInfo
    ): String {
        return buildString {
            appendLine("## ðŸ¤– AI Code Review")
            appendLine()
            appendLine("**PR #${prInfo.number}**: ${prInfo.title}")
            appendLine()

            // Summary
            appendLine("### ðŸ“‹ Summary")
            appendLine(result.summary)
            appendLine()

            // Statistics
            val stats = ReviewStatistics.fromReview(result, prInfo.changedFiles.size)
            if (result.issues.isNotEmpty()) {
                appendLine("**Issues Found**: ${stats.totalIssues} total")
                appendLine("- ðŸ”´ Critical: ${stats.criticalCount}")
                appendLine("- ðŸŸ  High: ${stats.highCount}")
                appendLine("- ðŸŸ¡ Medium: ${stats.mediumCount}")
                appendLine("- ðŸ”µ Low: ${stats.lowCount}")
                appendLine("- â„¹ï¸ Info: ${stats.infoCount}")
                appendLine()
            }

            // Issues by severity
            if (result.issues.isNotEmpty()) {
                val groupedIssues = result.issues.groupBy { it.severity }

                for (severityName in Severity.values().map { it.name }) {
                    val issues = groupedIssues[severityName] ?: continue
                    if (issues.isEmpty()) continue

                    val severity = Severity.valueOf(severityName)
                    appendLine("### ${getSeverityEmoji(severity)} ${severityName} Issues (${issues.size})")
                    appendLine()

                    // Group by category
                    val byCategory = issues.groupBy { it.category }
                    byCategory.forEach { (categoryName, categoryIssues) ->
                        val category = Category.valueOf(categoryName)
                        appendLine("#### ${getCategoryIcon(category)} ${formatCategoryName(category)}")
                        appendLine()

                        categoryIssues.forEach { issue ->
                            appendLine("**${issue.filePath}**${if (issue.lineNumber != null) " (line ${issue.lineNumber})" else ""}")
                            appendLine("- ${issue.message}")
                            if (issue.suggestion != null) {
                                appendLine("- ðŸ’¡ **Suggestion**: ${issue.suggestion}")
                            }
                            appendLine()
                        }
                    }
                }
            } else {
                appendLine("### âœ… No Issues Found")
                appendLine()
                appendLine("Great work! No significant issues detected in this PR.")
                appendLine()
            }

            // Positive aspects
            if (result.positives.isNotEmpty()) {
                appendLine("### âœ… Positive Aspects")
                appendLine()
                result.positives.forEach { positive ->
                    appendLine("- $positive")
                }
                appendLine()
            }

            // Overall assessment
            appendLine("### ðŸŽ¯ Overall Assessment")
            appendLine()
            appendLine(result.overallAssessment)
            appendLine()

            // Footer
            appendLine("---")
            appendLine("*Generated by [Code Assistant](https://github.com/anthropics/code-assistant) using RAG + Claude API*")
            appendLine("*Review triggered by command `/review`*")
        }
    }

    /**
     * Format short summary for notifications
     */
    fun formatSummary(result: CodeReviewResult): String {
        val stats = ReviewStatistics.fromReview(result, 0)
        return buildString {
            if (stats.totalIssues == 0) {
                append("âœ… No issues found")
            } else {
                append("Found ${stats.totalIssues} issues: ")
                val parts = mutableListOf<String>()
                if (stats.criticalCount > 0) parts.add("${stats.criticalCount} critical")
                if (stats.highCount > 0) parts.add("${stats.highCount} high")
                if (stats.mediumCount > 0) parts.add("${stats.mediumCount} medium")
                append(parts.joinToString(", "))
            }
        }
    }

    /**
     * Get emoji for severity level
     */
    private fun getSeverityEmoji(severity: Severity): String = when (severity) {
        Severity.CRITICAL -> "ðŸ”´"
        Severity.HIGH -> "ðŸŸ "
        Severity.MEDIUM -> "ðŸŸ¡"
        Severity.LOW -> "ðŸ”µ"
        Severity.INFO -> "â„¹ï¸"
    }

    /**
     * Get icon for category
     */
    private fun getCategoryIcon(category: Category): String = when (category) {
        Category.BUG -> "ðŸ›"
        Category.SECURITY -> "ðŸ”’"
        Category.PERFORMANCE -> "âš¡"
        Category.CODE_STYLE -> "ðŸŽ¨"
        Category.BEST_PRACTICES -> "ðŸ“š"
        Category.ARCHITECTURE -> "ðŸ—ï¸"
        Category.DOCUMENTATION -> "ðŸ“"
        Category.TESTING -> "ðŸ§ª"
    }

    /**
     * Format category name with spaces
     */
    private fun formatCategoryName(category: Category): String {
        return category.name.replace("_", " ")
            .split(" ")
            .joinToString(" ") { it.lowercase().replaceFirstChar { char -> char.uppercase() } }
    }
}